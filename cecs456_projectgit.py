# -*- coding: utf-8 -*-
"""cecs456_projectgit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qIIi3W5LOksB4byc6ZX0Hg4i-PZM3jve
"""

#load the kaggle.json file
!pip install kaggle

from google.colab import files
files.upload()  # Upload kaggle.json

import os
os.makedirs("/root/.kaggle", exist_ok=True)
os.rename("kaggle.json", "/root/.kaggle/kaggle.json")
os.chmod("/root/.kaggle/kaggle.json", 600)

!kaggle datasets download -d alessiocorrado99/animals10
!unzip -q animals10.zip -d animals10

!ls animals10

!ls animals10/raw-img

#import
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split

import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import cv2
import shutil
import random

raw_fol = "animals10/raw-img" #contains all images
base_fol = "animals10/split" #folder for the training , validation, and testing split images
#Folders for the training, validation, and testing images
train_fol = os.path.join(base_fol, "train")
val_fol   = os.path.join(base_fol, "val")
test_fol  = os.path.join(base_fol, "test")

#If they do not exists it creates the folders train, validation, and testing
for d in [train_fol, val_fol, test_fol]:
    os.makedirs(d, exist_ok=True)

classes = os.listdir(raw_fol)


#Goes through each class
for curr_class in classes:
    curr_class_fol = os.path.join(raw_fol, curr_class)
    images = os.listdir(curr_class_fol)
    random.shuffle(images) #mixes the images so the splits of training, validation, and testing are fairly equal
    x_total = len(images)
    x_train = int(0.8 * x_total) #80 images for training
    x_val   = int(0.1 * x_total) #10% images for validation / 10% for testing
    x_test  = x_total - x_train - x_val

    # Create subfolders(a folder for each class under train/validation/test)
    for split_fol in [train_fol, val_fol, test_fol]:
        os.makedirs(os.path.join(split_fol, curr_class), exist_ok=True)

    #Iterates through images to copy into the correct split
    for i, img_file in enumerate(images):
        og_loc = os.path.join(curr_class_fol, img_file)
        if i < x_train:
            dest = os.path.join(train_fol, curr_class, img_file)
        elif i < x_train + x_val:
            dest = os.path.join(val_fol, curr_class, img_file)
        else:
            dest = os.path.join(test_fol, curr_class, img_file)
        shutil.copyfile(og_loc, dest)

img_size = (128,128)
batch_size = 32


#Train data generator alongside w/ data augmentation
train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.1,
    height_shift_range=0.1,
    horizontal_flip=True
)

#rescaling to thevalidation and testing generators
val_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1./255)
test_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1./255)


#creating generators
train_generator = train_datagen.flow_from_directory(
    train_fol,
    target_size = img_size,
    batch_size = batch_size,
    class_mode = 'categorical'
)
val_generator = val_datagen.flow_from_directory(
    val_fol,
    target_size = img_size,
    batch_size = batch_size,
    class_mode='categorical'
)
test_generator = test_datagen.flow_from_directory(
    test_fol,
    target_size = img_size,
    batch_size = batch_size,
    class_mode='categorical',
    shuffle=False
)

#number of classes in the kaggle dataset being used
num_classes = len(train_generator.class_indices)

#This is the CNN
cnn = tf.keras.models.Sequential()


cnn.add(tf.keras.layers.Conv2D(32, kernel_size=3, activation='relu', padding='same', input_shape=(128,128,3)))
cnn.add(tf.keras.layers.Conv2D(32, kernel_size=3, activation='relu', padding='same'))
cnn.add(tf.keras.layers.MaxPooling2D(pool_size=2, strides=2))

cnn.add(tf.keras.layers.Conv2D(64, kernel_size=3, activation='relu', padding='same'))
cnn.add(tf.keras.layers.Conv2D(64, kernel_size=3, activation='relu', padding='same'))
cnn.add(tf.keras.layers.MaxPooling2D(pool_size=2, strides=2))

cnn.add(tf.keras.layers.Conv2D(128, kernel_size=3, activation='relu', padding='same'))
cnn.add(tf.keras.layers.MaxPooling2D(pool_size=2, strides=2))


cnn.add(tf.keras.layers.Flatten())
cnn.add(tf.keras.layers.Dense(128, activation='relu'))
cnn.add(tf.keras.layers.Dropout(0.5))

cnn.add(tf.keras.layers.Dense(num_classes, activation='softmax'))

cnn.summary()

#compile
cnn.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

#train model
history = cnn.fit(train_generator,epochs=30,validation_data=val_generator,)

#evaluate
score = cnn.evaluate(test_generator)

#Loss
print('Total loss on Testing Set:', score[0])

#Accuracy
print('Accuracy of Testing Set:', score[1])

#predict images


X_new, y_true = next(test_generator)

X_new, y_true = X_new[:3], y_true[:3]

# Predict class probabilities and round them (optional)
y_proba = cnn.predict(X_new)
y_proba.round(2)

y_pred = np.argmax(y_proba, axis=-1)

y_true_classes = np.argmax(y_true, axis=-1)

class_names = list(train_generator.class_indices.keys())

#Images displayed with predicted label and actual label
plt.figure(figsize=(7.2, 2.4))
for i, img in enumerate(X_new):
    plt.subplot(1, 3, i+1)
    plt.imshow(img)
    plt.axis('off')
    plt.title(class_names[y_pred[i]], fontsize=12)
plt.subplots_adjust(wspace=0.2, hspace=0.5)
plt.show()